<?php

/**
 * @file
 * Timefield taxonomy module file.
 *
 */

/**
 * Returns a list handlers that can provide time tagging info.
 */
function timefield_taxonomy_handler_info($field_type = NULL) {

  $handlers = array(
    'date' => array(
      'name' => 'date',
      'title' => t("Date/Time Field"),
      'description' => t('Get a time from a date/time enabled field'),
      'field_types' => array('datestamp', 'datetime'),
    ),
    'timefield' => array(
      'name' => 'timefield',
      'title' => t("Date/Time Field"),
      'description' => t('Get a time from a date/time enabled field'),
      'field_types' => array('timefield'),
    ),
  );
  if ($field_type) {
    $field_handlers = $handlers;
    foreach ($field_handlers as $i => $handler) {
      if (!isset($handler['field_types']) || !in_array($field_type, $handler['field_types'])) {
        unset($field_handlers[$i]);
      }
    }
    return $field_handlers;
  }
  return $handlers;
}

/**
 * Helper function to return supported field types for timefield_taxonomy
 * @return array of supported field keyed by field_type name.
 */
function timefield_taxonomy_supported_field_types() {
  $supported = array();

  $processors = timefield_taxonomy_handler_info();

  foreach ($processors as $processor) {
    if (isset($processor['field_types'])) {
      foreach ($processor['field_types'] as $field_type) {
        $supported[$field_type][] = $processor['name'];
      }
    }
  }

  return $supported;
}

/**
 * Implements hook_field_widget_info().
 */
function timefield_taxonomy_field_widget_info() {
  return array(
    'timefield_taxonomy' => array(
      'label' => t('Autotag from a date/time field'),
      'field types' => array('taxonomy_term_reference'),
    ),
  );
}

/**
 * Implements field_widget_settings_form().
 */
function timefield_taxonomy_field_widget_settings_form($this_field, $instance) {
  $settings = $instance['widget']['settings'];


  // Get fields on this entity
  $entity_fields = field_info_instances($instance['entity_type'], $instance['bundle']);
  // Get fields on selected vocabulary
  $current_vocabulary_fields = array();
  foreach ($this_field['settings']['allowed_values'] as $delta => $tree) {
    $current_possible_fields = field_info_instances('taxonomy_term', $tree['vocabulary']);
    foreach ($current_possible_fields as $index => $valid_field) {
      // we are checking here that this is a valid field for our purposes, i.e., it is a timefield
      // that has cardinality == 1 and that settings totime or todate is optional // required
      $eval_field = field_info_field($valid_field['field_name']);
      if ($eval_field['type'] == 'timefield' && $eval_field['settings']['totime'] <> 'never' && $eval_field['cardinality'] == 1) {
        $current_vocabulary_fields[$index] = $valid_field;
      }
    }
  }

  // Get all fields to match against our type
  $all_fields = field_info_fields();
  $supported_field_types = timefield_taxonomy_supported_field_types();
  $field_types = array();
  $valid_fields = array();
  $valid_match_fields = array();

  // Get a list of all valid fields that we both support and are part of this entity
  foreach ($all_fields as $field) {
    if (array_key_exists($field['field_name'], $entity_fields)) {
      if (in_array($field['type'], array_keys($supported_field_types)) && ($field['field_name'] != $this_field['field_name'])) {
        $valid_fields[$field['field_name']] = $entity_fields[$field['field_name']]['label'];
      }
    }
    if (array_key_exists($field['field_name'], $current_vocabulary_fields)) {
      if (in_array($field['type'], array_keys($supported_field_types)) && ($field['field_name'] != $this_field['field_name'])) {
        $valid_match_fields[$field['field_name']] = $current_vocabulary_fields[$field['field_name']]['label'];
      }
    }
  }

  $form['timefield_taxonomy_field'] = array(
    '#type' => 'select',
    '#title' => t('AutoTag from Current Field'),
    '#default_value' => isset($settings['timefield_taxonomy_field']) ? $settings['timefield_taxonomy_field']: '',
    '#options' => $valid_fields,
    '#description' => t('Select which field you would like to generate the timefield taxonomy from.'),
    '#required' => TRUE,
  );

  if (empty($valid_match_fields)) {
    drupal_set_message(t("You must add a timefield to this vocabulary with optional or required to time, and cardinality of 1."));
  }

  $form['timefield_taxonomy_match_field'] = array(
    '#type' => 'select',
    '#title' => t('Vocabulary Field for Matching'),
    '#default_value' => isset($settings['timefield_taxonomy_match_field']) ? $settings['timefield_taxonomy_match_field']: '',
    '#options' => $valid_match_fields,
    '#description' => t('Select the vocabulary field to match time to. <br />If this is a multi-value field, be sure to select "Unlimited" for Number of values in the Field Settings area.'),
    '#required' => TRUE,
  );

  $match_options = array(
    'lower bound first' => 'Match provider value by starting time',
    'upper bound first' => 'Match provider value by ending time',
    'inclusive first' => 'Match provider value by starting and ending time',
  );

  $form['timefield_taxonomy_match_options'] = array(
    '#type' => 'select',
    '#title' => t('How should the providing field be tagged'),
    '#default_value' => isset($settings['timefield_taxonomy_match_options']) ? $settings['timefield_taxonomy_match_options']: 'lower bound first',
    '#options' => $match_options,
    '#description' => t('Select the options to match time to.<br />If this is a multi-value field, be sure to select "Unlimited" for Number of values in the Field Settings area.'),
    '#required' => TRUE,
  );

  return $form;
}

/**
 * Implements hook_field_widget_form().
 */
function timefield_taxonomy_field_widget_form(&$form, &$form_state, $field, $instance, $langcode, $items, $delta, $base) {
  $element = $base;

  $element['tid'] = array(
   '#type' => 'hidden',
   '#element_validate' => array('timefield_taxonomy_widget_validate'),
  );
  $element['timefield_taxonomy_target'] = array(
   '#type' => 'hidden',
   '#value' => $instance['field_name'],
  );
  $element['timefield_taxonomy_source'] = array(
   '#type' => 'hidden',
   '#value' => isset($instance['widget']['settings']['timefield_taxonomy_field']) ? $instance['widget']['settings']['timefield_taxonomy_field'] : '',
  );
  $element['timefield_taxonomy_vocab_match'] = array(
   '#type' => 'hidden',
   '#value' => isset($instance['widget']['settings']['timefield_taxonomy_match_field']) ? $instance['widget']['settings']['timefield_taxonomy_match_field'] : '',
  );
  $element['timefield_taxonomy_match_options'] = array(
   '#type' => 'hidden',
   '#value' => isset($instance['widget']['settings']['timefield_taxonomy_match_options']) ? $instance['widget']['settings']['timefield_taxonomy_match_options'] : '',
  );
  return $element;
}

/**
 * Implements hook_widget_validate
 */
function timefield_taxonomy_widget_validate($element, &$form_state) {

  // Walk the form_state values, applying all instances of timefield_taxonomy source and target operations
  foreach ($form_state['values'] as &$field) {
    if (is_array($field)) {
      $lang = isset($form_state['values']['language']) ? $form_state['values']['language'] : LANGUAGE_NONE;
      if ((!empty($field[$lang][0]['timefield_taxonomy_source']) && !empty($field[$lang][0]['timefield_taxonomy_target']))) {

        $source = $field[$lang][0]['timefield_taxonomy_source'];
        $field_object = field_info_field($field[$lang][0]['timefield_taxonomy_source']);
        $match_field = $field[$lang][0]['timefield_taxonomy_vocab_match'];
        $match_options = $field[$lang][0]['timefield_taxonomy_match_options'];
        $target_field = $field[$lang][0]['timefield_taxonomy_target'];
        $field_cardinality = $form_state['field'][$target_field][$lang]['field']['cardinality'];
        $field[$lang] = array();
        if (isset($form_state['values'][$source][$lang])) {
          $tags = array();
          foreach ($form_state['values'][$source][$lang] as $delta => $item) {
            if (is_array($item) && !empty($item['value'])) {
              $tags[] = call_user_func('timefield_taxonomy_date_field', $field_object, $item, $match_field, $match_options);
            }
          }
          $field[$lang] = _timefield_taxonomy_aggregate_tags($tags, $field_cardinality);
        }
      }
    }
  }


}

/**
 * Main callback for process source field data against target field data
 */
function timefield_taxonomy_date_field($field, $field_item, $match_field, $options) {

  if ($field['type'] == 'timefield') {
    $start_time = timefield_time_to_integer($field_item['value']);
    if (isset($field_item['value2'])) {
      $end_time = timefield_time_to_integer($field_item['value2']);
    }
    else {
      $end_time = $start_time;
    }
  }
  elseif ($field['type'] == 'datetime' || $field['type'] == 'datestamp') {
    // exit if value is empty
    if (empty($field_item['value'])) return;
    $start_time = timefield_time_to_integer($field_item['value']) + $field_item['offset'];
    if (isset($field_item['value2'])) {
      $end_time = timefield_time_to_integer($field_item['value2']) + $field_item['offset2'];
    }
    else {
      $end_time = timefield_time_to_integer($field_item['value']) + $field_item['offset'];
    }

  }
  else {
    // "Add another" for multi-value fields ends up here.
    return;
  }
  switch ($options) {
    case 'lower bound first':
      return timefield_taxonomy_query($match_field, $start_time, $start_time);
      break;
    case 'upper bound first':
      return timefield_taxonomy_query($match_field, $end_time, $end_time);
      break;
    case 'inclusive first':
      return timefield_taxonomy_query($match_field, $start_time, $end_time);
      break;
  }
}

/**
 * Query function to find associated times
 */
function timefield_taxonomy_query($field, $start_time, $end_time) {

  $query = new EntityFieldQuery();
  $query->entityCondition('entity_type', 'taxonomy_term', '=');
  $query->fieldCondition($field, 'value', $start_time, '<=');
  $query->fieldCondition($field, 'value2', $end_time, '>=');

  $results = $query->execute();

  $return = array();
  foreach ($results as $tax => $res) {
    foreach ($res as $ob) {
      $return[] = $ob->tid;
    }
  }
  return $return;

}

/**
 * Helper function to aggregate tags, limiting to target field cardinality
 */
function _timefield_taxonomy_aggregate_tags($tags, $field_cardinality) {
  $agg_tags = array();
  $count = 0;
  foreach ($tags as $tag) {
    foreach ($tag as $t) {
      if (!in_array(array('tid' => $t), $agg_tags)) {
        if ($count < $field_cardinality || $field_cardinality == -1 ) {
          $agg_tags[] = array('tid' => $t);
        }
        $count += 1;
      }
    }
  }
  return $agg_tags;
}
